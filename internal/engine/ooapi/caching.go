// Code generated by go generate; DO NOT EDIT.
// 2021-02-26 11:28:50.037303675 +0100 CET m=+0.491135053

package ooapi

//go:generate go run ./internal/generator

import (
	"context"
	"reflect"

	"github.com/ooni/probe-cli/v3/internal/engine/ooapi/apimodel"
)

// MeasurementMetaCache implements caching for MeasurementMetaAPI.
type MeasurementMetaCache struct {
	API      MeasurementMetaCaller // mandatory
	GobCodec GobCodec              // optional
	KVStore  KVStore               // mandatory
}

type cacheEntryForMeasurementMeta struct {
	Req  *apimodel.MeasurementMetaRequest
	Resp *apimodel.MeasurementMetaResponse
}

// Call calls the API and implements caching.
func (c *MeasurementMetaCache) Call(ctx context.Context, req *apimodel.MeasurementMetaRequest) (*apimodel.MeasurementMetaResponse, error) {
	if resp, _ := c.readcache(req); resp != nil {
		return resp, nil
	}
	resp, err := c.API.Call(ctx, req)
	if err != nil {
		return nil, err
	}
	if err := c.writecache(req, resp); err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *MeasurementMetaCache) gobCodec() GobCodec {
	if c.GobCodec != nil {
		return c.GobCodec
	}
	return &defaultGobCodec{}
}

func (c *MeasurementMetaCache) getcache() ([]cacheEntryForMeasurementMeta, error) {
	data, err := c.KVStore.Get("MeasurementMeta.cache")
	if err != nil {
		return nil, err
	}
	var out []cacheEntryForMeasurementMeta
	if err := c.gobCodec().Decode(data, &out); err != nil {
		return nil, err
	}
	return out, nil
}

func (c *MeasurementMetaCache) setcache(in []cacheEntryForMeasurementMeta) error {
	data, err := c.gobCodec().Encode(in)
	if err != nil {
		return err
	}
	return c.KVStore.Set("MeasurementMeta.cache", data)
}

func (c *MeasurementMetaCache) readcache(req *apimodel.MeasurementMetaRequest) (*apimodel.MeasurementMetaResponse, error) {
	cache, err := c.getcache()
	if err != nil {
		return nil, err
	}
	for _, cur := range cache {
		if reflect.DeepEqual(req, cur.Req) {
			return cur.Resp, nil
		}
	}
	return nil, errCacheNotFound
}

func (c *MeasurementMetaCache) writecache(req *apimodel.MeasurementMetaRequest, resp *apimodel.MeasurementMetaResponse) error {
	cache, _ := c.getcache()
	out := []cacheEntryForMeasurementMeta{{Req: req, Resp: resp}}
	const toomany = 64
	for idx, cur := range cache {
		if reflect.DeepEqual(req, cur.Req) {
			continue // we already updated the cache
		}
		if idx > toomany {
			break
		}
		out = append(out, cur)
	}
	return c.setcache(out)
}

var _ MeasurementMetaCaller = &MeasurementMetaCache{}
