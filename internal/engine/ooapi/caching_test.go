// Code generated by go generate; DO NOT EDIT.
// 2021-02-23 23:33:20.359319 +0100 CET m=+2.992650132

package ooapi

//go:generate go run ./internal/generator

import (
	"context"
	"errors"
	"testing"

	"github.com/google/go-cmp/cmp"
	"github.com/ooni/probe-cli/v3/internal/engine/ooapi/apimodel"
)

func TestCacheCheckInAPISuccess(t *testing.T) {
	ff := &fakeFill{}
	var expect *apimodel.CheckInResponse
	ff.fill(&expect)
	cache := &CheckInCache{
		API: &FakeCheckInAPI{
			Response: expect,
		},
		KVStore: &memkvstore{},
	}
	var req *apimodel.CheckInRequest
	ff.fill(&req)
	ctx := context.Background()
	resp, err := cache.Call(ctx, req)
	if err != nil {
		t.Fatal(err)
	}
	if resp == nil {
		t.Fatal("expected non-nil response")
	}
	if diff := cmp.Diff(expect, resp); diff != "" {
		t.Fatal(diff)
	}
}

func TestCacheCheckInAPIWriteCacheError(t *testing.T) {
	errMocked := errors.New("mocked error")
	ff := &fakeFill{}
	var expect *apimodel.CheckInResponse
	ff.fill(&expect)
	cache := &CheckInCache{
		API: &FakeCheckInAPI{
			Response: expect,
		},
		KVStore: &FakeKVStore{SetError: errMocked},
	}
	var req *apimodel.CheckInRequest
	ff.fill(&req)
	ctx := context.Background()
	resp, err := cache.Call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil response")
	}
}

func TestCacheCheckInAPIFailureWithNoCache(t *testing.T) {
	errMocked := errors.New("mocked error")
	ff := &fakeFill{}
	cache := &CheckInCache{
		API: &FakeCheckInAPI{
			Err: errMocked,
		},
		KVStore: &memkvstore{},
	}
	var req *apimodel.CheckInRequest
	ff.fill(&req)
	ctx := context.Background()
	resp, err := cache.Call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil response")
	}
}

func TestCacheCheckInAPIFailureWithPreviousCache(t *testing.T) {
	ff := &fakeFill{}
	var expect *apimodel.CheckInResponse
	ff.fill(&expect)
	fakeapi := &FakeCheckInAPI{
		Response: expect,
	}
	cache := &CheckInCache{
		API:     fakeapi,
		KVStore: &memkvstore{},
	}
	var req *apimodel.CheckInRequest
	ff.fill(&req)
	ctx := context.Background()
	// first pass with no error at all
	// use a separate scope to be sure we avoid mistakes
	{
		resp, err := cache.Call(ctx, req)
		if err != nil {
			t.Fatal(err)
		}
		if resp == nil {
			t.Fatal("expected non-nil response")
		}
		if diff := cmp.Diff(expect, resp); diff != "" {
			t.Fatal(diff)
		}
	}
	// second pass with failure
	errMocked := errors.New("mocked error")
	fakeapi.Err = errMocked
	fakeapi.Response = nil
	resp2, err := cache.Call(ctx, req)
	if err != nil {
		t.Fatal(err)
	}
	if resp2 == nil {
		t.Fatal("expected non-nil response")
	}
	if diff := cmp.Diff(expect, resp2); diff != "" {
		t.Fatal(diff)
	}
}

func TestCacheCheckInAPISetcacheWithEncodeError(t *testing.T) {
	ff := &fakeFill{}
	errMocked := errors.New("mocked error")
	var in []cacheEntryForCheckIn
	ff.fill(&in)
	cache := &CheckInCache{
		GobCodec: &FakeCodec{EncodeErr: errMocked},
	}
	err := cache.setcache(in)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
}

func TestCacheCheckInAPIReadCacheNotFound(t *testing.T) {
	ff := &fakeFill{}
	var incache []cacheEntryForCheckIn
	ff.fill(&incache)
	cache := &CheckInCache{
		KVStore: &memkvstore{},
	}
	err := cache.setcache(incache)
	if err != nil {
		t.Fatal(err)
	}
	var req *apimodel.CheckInRequest
	ff.fill(&req)
	out, err := cache.readcache(req)
	if !errors.Is(err, errCacheNotFound) {
		t.Fatal("not the error we expected", err)
	}
	if out != nil {
		t.Fatal("expected nil here")
	}
}

func TestCacheCheckInAPIWriteCacheDuplicate(t *testing.T) {
	ff := &fakeFill{}
	var req *apimodel.CheckInRequest
	ff.fill(&req)
	var resp1 *apimodel.CheckInResponse
	ff.fill(&resp1)
	var resp2 *apimodel.CheckInResponse
	ff.fill(&resp2)
	cache := &CheckInCache{
		KVStore: &memkvstore{},
	}
	err := cache.writecache(req, resp1)
	if err != nil {
		t.Fatal(err)
	}
	err = cache.writecache(req, resp2)
	if err != nil {
		t.Fatal(err)
	}
	out, err := cache.readcache(req)
	if err != nil {
		t.Fatal(err)
	}
	if out == nil {
		t.Fatal("expected non-nil here")
	}
	if diff := cmp.Diff(resp2, out); diff != "" {
		t.Fatal(diff)
	}
}

func TestCacheCheckInAPICacheSizeLimited(t *testing.T) {
	ff := &fakeFill{}
	cache := &CheckInCache{
		KVStore: &memkvstore{},
	}
	var prev int
	for {
		var req *apimodel.CheckInRequest
		ff.fill(&req)
		var resp *apimodel.CheckInResponse
		ff.fill(&resp)
		err := cache.writecache(req, resp)
		if err != nil {
			t.Fatal(err)
		}
		out, err := cache.getcache()
		if err != nil {
			t.Fatal(err)
		}
		if len(out) > prev {
			prev = len(out)
			continue
		}
		break
	}
}

func TestCacheMeasurementMetaAPISuccess(t *testing.T) {
	ff := &fakeFill{}
	var expect *apimodel.MeasurementMetaResponse
	ff.fill(&expect)
	cache := &MeasurementMetaCache{
		API: &FakeMeasurementMetaAPI{
			Response: expect,
		},
		KVStore: &memkvstore{},
	}
	var req *apimodel.MeasurementMetaRequest
	ff.fill(&req)
	ctx := context.Background()
	resp, err := cache.Call(ctx, req)
	if err != nil {
		t.Fatal(err)
	}
	if resp == nil {
		t.Fatal("expected non-nil response")
	}
	if diff := cmp.Diff(expect, resp); diff != "" {
		t.Fatal(diff)
	}
}

func TestCacheMeasurementMetaAPIWriteCacheError(t *testing.T) {
	errMocked := errors.New("mocked error")
	ff := &fakeFill{}
	var expect *apimodel.MeasurementMetaResponse
	ff.fill(&expect)
	cache := &MeasurementMetaCache{
		API: &FakeMeasurementMetaAPI{
			Response: expect,
		},
		KVStore: &FakeKVStore{SetError: errMocked},
	}
	var req *apimodel.MeasurementMetaRequest
	ff.fill(&req)
	ctx := context.Background()
	resp, err := cache.Call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil response")
	}
}

func TestCacheMeasurementMetaAPIFailureWithNoCache(t *testing.T) {
	errMocked := errors.New("mocked error")
	ff := &fakeFill{}
	cache := &MeasurementMetaCache{
		API: &FakeMeasurementMetaAPI{
			Err: errMocked,
		},
		KVStore: &memkvstore{},
	}
	var req *apimodel.MeasurementMetaRequest
	ff.fill(&req)
	ctx := context.Background()
	resp, err := cache.Call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil response")
	}
}

func TestCacheMeasurementMetaAPIFailureWithPreviousCache(t *testing.T) {
	ff := &fakeFill{}
	var expect *apimodel.MeasurementMetaResponse
	ff.fill(&expect)
	fakeapi := &FakeMeasurementMetaAPI{
		Response: expect,
	}
	cache := &MeasurementMetaCache{
		API:     fakeapi,
		KVStore: &memkvstore{},
	}
	var req *apimodel.MeasurementMetaRequest
	ff.fill(&req)
	ctx := context.Background()
	// first pass with no error at all
	// use a separate scope to be sure we avoid mistakes
	{
		resp, err := cache.Call(ctx, req)
		if err != nil {
			t.Fatal(err)
		}
		if resp == nil {
			t.Fatal("expected non-nil response")
		}
		if diff := cmp.Diff(expect, resp); diff != "" {
			t.Fatal(diff)
		}
	}
	// second pass with failure
	errMocked := errors.New("mocked error")
	fakeapi.Err = errMocked
	fakeapi.Response = nil
	resp2, err := cache.Call(ctx, req)
	if err != nil {
		t.Fatal(err)
	}
	if resp2 == nil {
		t.Fatal("expected non-nil response")
	}
	if diff := cmp.Diff(expect, resp2); diff != "" {
		t.Fatal(diff)
	}
}

func TestCacheMeasurementMetaAPISetcacheWithEncodeError(t *testing.T) {
	ff := &fakeFill{}
	errMocked := errors.New("mocked error")
	var in []cacheEntryForMeasurementMeta
	ff.fill(&in)
	cache := &MeasurementMetaCache{
		GobCodec: &FakeCodec{EncodeErr: errMocked},
	}
	err := cache.setcache(in)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
}

func TestCacheMeasurementMetaAPIReadCacheNotFound(t *testing.T) {
	ff := &fakeFill{}
	var incache []cacheEntryForMeasurementMeta
	ff.fill(&incache)
	cache := &MeasurementMetaCache{
		KVStore: &memkvstore{},
	}
	err := cache.setcache(incache)
	if err != nil {
		t.Fatal(err)
	}
	var req *apimodel.MeasurementMetaRequest
	ff.fill(&req)
	out, err := cache.readcache(req)
	if !errors.Is(err, errCacheNotFound) {
		t.Fatal("not the error we expected", err)
	}
	if out != nil {
		t.Fatal("expected nil here")
	}
}

func TestCacheMeasurementMetaAPIWriteCacheDuplicate(t *testing.T) {
	ff := &fakeFill{}
	var req *apimodel.MeasurementMetaRequest
	ff.fill(&req)
	var resp1 *apimodel.MeasurementMetaResponse
	ff.fill(&resp1)
	var resp2 *apimodel.MeasurementMetaResponse
	ff.fill(&resp2)
	cache := &MeasurementMetaCache{
		KVStore: &memkvstore{},
	}
	err := cache.writecache(req, resp1)
	if err != nil {
		t.Fatal(err)
	}
	err = cache.writecache(req, resp2)
	if err != nil {
		t.Fatal(err)
	}
	out, err := cache.readcache(req)
	if err != nil {
		t.Fatal(err)
	}
	if out == nil {
		t.Fatal("expected non-nil here")
	}
	if diff := cmp.Diff(resp2, out); diff != "" {
		t.Fatal(diff)
	}
}

func TestCacheMeasurementMetaAPICacheSizeLimited(t *testing.T) {
	ff := &fakeFill{}
	cache := &MeasurementMetaCache{
		KVStore: &memkvstore{},
	}
	var prev int
	for {
		var req *apimodel.MeasurementMetaRequest
		ff.fill(&req)
		var resp *apimodel.MeasurementMetaResponse
		ff.fill(&resp)
		err := cache.writecache(req, resp)
		if err != nil {
			t.Fatal(err)
		}
		out, err := cache.getcache()
		if err != nil {
			t.Fatal(err)
		}
		if len(out) > prev {
			prev = len(out)
			continue
		}
		break
	}
}

func TestCacheTestHelpersAPISuccess(t *testing.T) {
	ff := &fakeFill{}
	var expect apimodel.TestHelpersResponse
	ff.fill(&expect)
	cache := &TestHelpersCache{
		API: &FakeTestHelpersAPI{
			Response: expect,
		},
		KVStore: &memkvstore{},
	}
	var req *apimodel.TestHelpersRequest
	ff.fill(&req)
	ctx := context.Background()
	resp, err := cache.Call(ctx, req)
	if err != nil {
		t.Fatal(err)
	}
	if resp == nil {
		t.Fatal("expected non-nil response")
	}
	if diff := cmp.Diff(expect, resp); diff != "" {
		t.Fatal(diff)
	}
}

func TestCacheTestHelpersAPIWriteCacheError(t *testing.T) {
	errMocked := errors.New("mocked error")
	ff := &fakeFill{}
	var expect apimodel.TestHelpersResponse
	ff.fill(&expect)
	cache := &TestHelpersCache{
		API: &FakeTestHelpersAPI{
			Response: expect,
		},
		KVStore: &FakeKVStore{SetError: errMocked},
	}
	var req *apimodel.TestHelpersRequest
	ff.fill(&req)
	ctx := context.Background()
	resp, err := cache.Call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil response")
	}
}

func TestCacheTestHelpersAPIFailureWithNoCache(t *testing.T) {
	errMocked := errors.New("mocked error")
	ff := &fakeFill{}
	cache := &TestHelpersCache{
		API: &FakeTestHelpersAPI{
			Err: errMocked,
		},
		KVStore: &memkvstore{},
	}
	var req *apimodel.TestHelpersRequest
	ff.fill(&req)
	ctx := context.Background()
	resp, err := cache.Call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil response")
	}
}

func TestCacheTestHelpersAPIFailureWithPreviousCache(t *testing.T) {
	ff := &fakeFill{}
	var expect apimodel.TestHelpersResponse
	ff.fill(&expect)
	fakeapi := &FakeTestHelpersAPI{
		Response: expect,
	}
	cache := &TestHelpersCache{
		API:     fakeapi,
		KVStore: &memkvstore{},
	}
	var req *apimodel.TestHelpersRequest
	ff.fill(&req)
	ctx := context.Background()
	// first pass with no error at all
	// use a separate scope to be sure we avoid mistakes
	{
		resp, err := cache.Call(ctx, req)
		if err != nil {
			t.Fatal(err)
		}
		if resp == nil {
			t.Fatal("expected non-nil response")
		}
		if diff := cmp.Diff(expect, resp); diff != "" {
			t.Fatal(diff)
		}
	}
	// second pass with failure
	errMocked := errors.New("mocked error")
	fakeapi.Err = errMocked
	fakeapi.Response = nil
	resp2, err := cache.Call(ctx, req)
	if err != nil {
		t.Fatal(err)
	}
	if resp2 == nil {
		t.Fatal("expected non-nil response")
	}
	if diff := cmp.Diff(expect, resp2); diff != "" {
		t.Fatal(diff)
	}
}

func TestCacheTestHelpersAPISetcacheWithEncodeError(t *testing.T) {
	ff := &fakeFill{}
	errMocked := errors.New("mocked error")
	var in []cacheEntryForTestHelpers
	ff.fill(&in)
	cache := &TestHelpersCache{
		GobCodec: &FakeCodec{EncodeErr: errMocked},
	}
	err := cache.setcache(in)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
}

func TestCacheTestHelpersAPIWriteCacheDuplicate(t *testing.T) {
	ff := &fakeFill{}
	var req *apimodel.TestHelpersRequest
	ff.fill(&req)
	var resp1 apimodel.TestHelpersResponse
	ff.fill(&resp1)
	var resp2 apimodel.TestHelpersResponse
	ff.fill(&resp2)
	cache := &TestHelpersCache{
		KVStore: &memkvstore{},
	}
	err := cache.writecache(req, resp1)
	if err != nil {
		t.Fatal(err)
	}
	err = cache.writecache(req, resp2)
	if err != nil {
		t.Fatal(err)
	}
	out, err := cache.readcache(req)
	if err != nil {
		t.Fatal(err)
	}
	if out == nil {
		t.Fatal("expected non-nil here")
	}
	if diff := cmp.Diff(resp2, out); diff != "" {
		t.Fatal(diff)
	}
}

func TestCacheTorTargetsAPISuccess(t *testing.T) {
	ff := &fakeFill{}
	var expect apimodel.TorTargetsResponse
	ff.fill(&expect)
	cache := &TorTargetsCache{
		API: &FakeTorTargetsAPI{
			Response: expect,
		},
		KVStore: &memkvstore{},
	}
	var req *apimodel.TorTargetsRequest
	ff.fill(&req)
	ctx := context.Background()
	resp, err := cache.Call(ctx, req)
	if err != nil {
		t.Fatal(err)
	}
	if resp == nil {
		t.Fatal("expected non-nil response")
	}
	if diff := cmp.Diff(expect, resp); diff != "" {
		t.Fatal(diff)
	}
}

func TestCacheTorTargetsAPIWriteCacheError(t *testing.T) {
	errMocked := errors.New("mocked error")
	ff := &fakeFill{}
	var expect apimodel.TorTargetsResponse
	ff.fill(&expect)
	cache := &TorTargetsCache{
		API: &FakeTorTargetsAPI{
			Response: expect,
		},
		KVStore: &FakeKVStore{SetError: errMocked},
	}
	var req *apimodel.TorTargetsRequest
	ff.fill(&req)
	ctx := context.Background()
	resp, err := cache.Call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil response")
	}
}

func TestCacheTorTargetsAPIFailureWithNoCache(t *testing.T) {
	errMocked := errors.New("mocked error")
	ff := &fakeFill{}
	cache := &TorTargetsCache{
		API: &FakeTorTargetsAPI{
			Err: errMocked,
		},
		KVStore: &memkvstore{},
	}
	var req *apimodel.TorTargetsRequest
	ff.fill(&req)
	ctx := context.Background()
	resp, err := cache.Call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil response")
	}
}

func TestCacheTorTargetsAPIFailureWithPreviousCache(t *testing.T) {
	ff := &fakeFill{}
	var expect apimodel.TorTargetsResponse
	ff.fill(&expect)
	fakeapi := &FakeTorTargetsAPI{
		Response: expect,
	}
	cache := &TorTargetsCache{
		API:     fakeapi,
		KVStore: &memkvstore{},
	}
	var req *apimodel.TorTargetsRequest
	ff.fill(&req)
	ctx := context.Background()
	// first pass with no error at all
	// use a separate scope to be sure we avoid mistakes
	{
		resp, err := cache.Call(ctx, req)
		if err != nil {
			t.Fatal(err)
		}
		if resp == nil {
			t.Fatal("expected non-nil response")
		}
		if diff := cmp.Diff(expect, resp); diff != "" {
			t.Fatal(diff)
		}
	}
	// second pass with failure
	errMocked := errors.New("mocked error")
	fakeapi.Err = errMocked
	fakeapi.Response = nil
	resp2, err := cache.Call(ctx, req)
	if err != nil {
		t.Fatal(err)
	}
	if resp2 == nil {
		t.Fatal("expected non-nil response")
	}
	if diff := cmp.Diff(expect, resp2); diff != "" {
		t.Fatal(diff)
	}
}

func TestCacheTorTargetsAPISetcacheWithEncodeError(t *testing.T) {
	ff := &fakeFill{}
	errMocked := errors.New("mocked error")
	var in []cacheEntryForTorTargets
	ff.fill(&in)
	cache := &TorTargetsCache{
		GobCodec: &FakeCodec{EncodeErr: errMocked},
	}
	err := cache.setcache(in)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
}

func TestCacheTorTargetsAPIWriteCacheDuplicate(t *testing.T) {
	ff := &fakeFill{}
	var req *apimodel.TorTargetsRequest
	ff.fill(&req)
	var resp1 apimodel.TorTargetsResponse
	ff.fill(&resp1)
	var resp2 apimodel.TorTargetsResponse
	ff.fill(&resp2)
	cache := &TorTargetsCache{
		KVStore: &memkvstore{},
	}
	err := cache.writecache(req, resp1)
	if err != nil {
		t.Fatal(err)
	}
	err = cache.writecache(req, resp2)
	if err != nil {
		t.Fatal(err)
	}
	out, err := cache.readcache(req)
	if err != nil {
		t.Fatal(err)
	}
	if out == nil {
		t.Fatal("expected non-nil here")
	}
	if diff := cmp.Diff(resp2, out); diff != "" {
		t.Fatal(diff)
	}
}

func TestCacheURLsAPISuccess(t *testing.T) {
	ff := &fakeFill{}
	var expect *apimodel.URLsResponse
	ff.fill(&expect)
	cache := &URLsCache{
		API: &FakeURLsAPI{
			Response: expect,
		},
		KVStore: &memkvstore{},
	}
	var req *apimodel.URLsRequest
	ff.fill(&req)
	ctx := context.Background()
	resp, err := cache.Call(ctx, req)
	if err != nil {
		t.Fatal(err)
	}
	if resp == nil {
		t.Fatal("expected non-nil response")
	}
	if diff := cmp.Diff(expect, resp); diff != "" {
		t.Fatal(diff)
	}
}

func TestCacheURLsAPIWriteCacheError(t *testing.T) {
	errMocked := errors.New("mocked error")
	ff := &fakeFill{}
	var expect *apimodel.URLsResponse
	ff.fill(&expect)
	cache := &URLsCache{
		API: &FakeURLsAPI{
			Response: expect,
		},
		KVStore: &FakeKVStore{SetError: errMocked},
	}
	var req *apimodel.URLsRequest
	ff.fill(&req)
	ctx := context.Background()
	resp, err := cache.Call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil response")
	}
}

func TestCacheURLsAPIFailureWithNoCache(t *testing.T) {
	errMocked := errors.New("mocked error")
	ff := &fakeFill{}
	cache := &URLsCache{
		API: &FakeURLsAPI{
			Err: errMocked,
		},
		KVStore: &memkvstore{},
	}
	var req *apimodel.URLsRequest
	ff.fill(&req)
	ctx := context.Background()
	resp, err := cache.Call(ctx, req)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
	if resp != nil {
		t.Fatal("expected nil response")
	}
}

func TestCacheURLsAPIFailureWithPreviousCache(t *testing.T) {
	ff := &fakeFill{}
	var expect *apimodel.URLsResponse
	ff.fill(&expect)
	fakeapi := &FakeURLsAPI{
		Response: expect,
	}
	cache := &URLsCache{
		API:     fakeapi,
		KVStore: &memkvstore{},
	}
	var req *apimodel.URLsRequest
	ff.fill(&req)
	ctx := context.Background()
	// first pass with no error at all
	// use a separate scope to be sure we avoid mistakes
	{
		resp, err := cache.Call(ctx, req)
		if err != nil {
			t.Fatal(err)
		}
		if resp == nil {
			t.Fatal("expected non-nil response")
		}
		if diff := cmp.Diff(expect, resp); diff != "" {
			t.Fatal(diff)
		}
	}
	// second pass with failure
	errMocked := errors.New("mocked error")
	fakeapi.Err = errMocked
	fakeapi.Response = nil
	resp2, err := cache.Call(ctx, req)
	if err != nil {
		t.Fatal(err)
	}
	if resp2 == nil {
		t.Fatal("expected non-nil response")
	}
	if diff := cmp.Diff(expect, resp2); diff != "" {
		t.Fatal(diff)
	}
}

func TestCacheURLsAPISetcacheWithEncodeError(t *testing.T) {
	ff := &fakeFill{}
	errMocked := errors.New("mocked error")
	var in []cacheEntryForURLs
	ff.fill(&in)
	cache := &URLsCache{
		GobCodec: &FakeCodec{EncodeErr: errMocked},
	}
	err := cache.setcache(in)
	if !errors.Is(err, errMocked) {
		t.Fatal("not the error we expected", err)
	}
}

func TestCacheURLsAPIReadCacheNotFound(t *testing.T) {
	ff := &fakeFill{}
	var incache []cacheEntryForURLs
	ff.fill(&incache)
	cache := &URLsCache{
		KVStore: &memkvstore{},
	}
	err := cache.setcache(incache)
	if err != nil {
		t.Fatal(err)
	}
	var req *apimodel.URLsRequest
	ff.fill(&req)
	out, err := cache.readcache(req)
	if !errors.Is(err, errCacheNotFound) {
		t.Fatal("not the error we expected", err)
	}
	if out != nil {
		t.Fatal("expected nil here")
	}
}

func TestCacheURLsAPIWriteCacheDuplicate(t *testing.T) {
	ff := &fakeFill{}
	var req *apimodel.URLsRequest
	ff.fill(&req)
	var resp1 *apimodel.URLsResponse
	ff.fill(&resp1)
	var resp2 *apimodel.URLsResponse
	ff.fill(&resp2)
	cache := &URLsCache{
		KVStore: &memkvstore{},
	}
	err := cache.writecache(req, resp1)
	if err != nil {
		t.Fatal(err)
	}
	err = cache.writecache(req, resp2)
	if err != nil {
		t.Fatal(err)
	}
	out, err := cache.readcache(req)
	if err != nil {
		t.Fatal(err)
	}
	if out == nil {
		t.Fatal("expected non-nil here")
	}
	if diff := cmp.Diff(resp2, out); diff != "" {
		t.Fatal(diff)
	}
}

func TestCacheURLsAPICacheSizeLimited(t *testing.T) {
	ff := &fakeFill{}
	cache := &URLsCache{
		KVStore: &memkvstore{},
	}
	var prev int
	for {
		var req *apimodel.URLsRequest
		ff.fill(&req)
		var resp *apimodel.URLsResponse
		ff.fill(&resp)
		err := cache.writecache(req, resp)
		if err != nil {
			t.Fatal(err)
		}
		out, err := cache.getcache()
		if err != nil {
			t.Fatal(err)
		}
		if len(out) > prev {
			prev = len(out)
			continue
		}
		break
	}
}
