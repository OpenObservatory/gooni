#!/usr/bin/env python3

""" Build script for ooniprobe. You can get documentation regarding
its usage by running `./build --help`. """

from __future__ import annotations

import datetime
import getopt
import glob
import hashlib
import os
import platform
import shlex
import shutil
import subprocess
import sys
import tarfile
import urllib.request
import zipfile

from collections.abc import Callable
from typing import Any
from typing import Dict
from typing import List
from typing import NoReturn
from typing import Optional
from typing import Protocol


class StaticConfig:
    """StaticConfig contains static configuration. This includes the version
    numbers and sha256s of what we download and the directories where we store
    what we download. We want to change these settings ~frequently, i.e.,
    every time there is an update of the tools we use."""

    # Versions and signatures

    def golang_go_version(self) -> str:
        """golang_go_version is the version of github.com/golang/go we use."""
        return "1.16.3"

    def android_build_tools_version(self) -> str:
        """android_build_tools_version returns the Android build tools version."""
        return "29.0.3"

    def android_ndk_version(self) -> str:
        """android_ndk_version is the Android NDK version."""
        return "22.1.7171670"

    def android_cmdline_tools_version(self) -> str:
        """android_cmdline_tools_version is the command line tools version."""
        return "6858069"

    def android_platform_version(self) -> str:
        """android_platform_version is the platform version."""
        return "android-30"

    def android_cmdline_tools_sha256(self) -> Dict[str, str]:
        """android_cmdline_tools_sha256 contains command line tools SHA256s."""
        return {
            "darwin": "58a55d9c5bcacd7c42170d2cf2c9ae2889c6797a6128307aaf69100636f54a13",
            "linux": "87f6dcf41d4e642e37ba03cb2e387a542aa0bd73cb689a9e7152aad40a6e7a08",
        }

    def golang_go_sha256(self) -> Dict[str, Dict[str, str]]:
        """golang_go_sha256 contains the SHA256s of golang/go binary distributions."""
        return {
            "linux": {
                "amd64": "951a3c7c6ce4e56ad883f97d9db74d3d6d80d5fec77455c6ada6c1f7ac4776d2",
                "arm64": "566b1d6f17d2bc4ad5f81486f0df44f3088c3ed47a3bec4099d8ed9939e90d5d",
            },
            "darwin": {
                "amd64": "6bb1cf421f8abc2a9a4e39140b7397cdae6aca3e8d36dcff39a1a77f4f1170ac",
                "arm64": "f4e96bbcd5d2d1942f5b55d9e4ab19564da4fad192012f6d7b0b9b055ba4208f",
            },
        }

    # Paths

    def golang_go_root_dir(self) -> str:
        """golang_go_root_dir is the directory in which we install
        the github.com/golang/go binary distribution."""
        return os.path.join(
            self.cachedir(),
            "sdk",
            "golang.org",
            "go{}".format(
                self.golang_go_version(),
            ),
        )

    def oonigo_repo_url(self) -> str:
        """oonigo_repo_url is the repository containing our Go fork."""
        return "https://github.com/ooni/go"

    def oonigo_source_dir(self) -> str:
        """oonigo_source_dir is where we clone our Go fork (aka "oonigo")."""
        return os.path.join(self.cachedir(), "sdk", "github.com", "ooni", "go")

    def oonigo_bin_dir(self) -> str:
        """oonigo_bin_dir is the directory where oonigo's "go" is installed."""
        return os.path.join(self.oonigo_source_dir(), "bin")

    def probe_private_repo_url(self) -> str:
        """probe_private_repo_url is the URL of the optional repo containing
        private data required by some build configurations."""
        return "git@github.com:ooni/probe-private"

    def oonigo_branch(self) -> str:
        """oonigo_branch is the oonigo branch to checkout."""
        return "ooni"

    def probe_private_source_dir(self) -> str:
        """probe_private_source_dir is the directory where we clone the
        repository containing private configurations."""
        return os.path.join(
            self.cachedir(), "sdk", "github.com", "ooni", "probe-private"
        )

    def gopath(self) -> str:
        """gopath is the directory that we will use as a GOPATH when
        using our own fork of Go. This choice ensures that the
        binaries we will be using are separate from the default
        ones, which typically live in $HOME/go. Even though we're
        prepared for a system where "go" is not in PATH, a tool
        like VSCode is capable to downloading and using a specific
        version of Go, which will put its data in $HOME/go."""
        return os.path.join(self.cachedir(), "gopath")

    def android_sdk_root_dir(self) -> str:
        """android_sdk_root_dir is the dir where we install the SDK."""
        return os.path.join(self.cachedir(), "sdk", "android.com")

    def cachedir(self) -> str:
        """cachedir is the directory where we store state."""
        return os.path.join(os.path.expandvars("${HOME}"), ".ooniprobe-build")


class AndroidConfig(Protocol):
    """AndroidConfig contains config for AndroidTask."""

    def bundle(self) -> bool:
        """bundle returns true if the user wants us to
        create the bundle.jar file."""

    def debugging(self) -> bool:
        """debugging returns true when the user has requested
        us to enable debugging."""

    def dry_run(self) -> bool:
        """dry_run returns whether this is a dry run."""

    def goos(self) -> str:
        """goos returns the GOOS for which to build."""

    def no_embed_psiphon(self) -> bool:
        """no_embed_psiphon returns true when the user has
        requested us to avoid embedding a psiphon config."""

    def no_private_sdks(self) -> bool:
        """no_private_sdks returns true when the user has
        requested us to avoid using our private SKDs, under
        the assumption that the system already contains
        suitable SDKs for building and there are environment
        variables in place pointing to them."""

    def sign(self) -> str:
        """sign returns the email with which we need to PGP-sign
        artefacts, if any, otherwise it returns ""."""

    def verbose(self) -> bool:
        """verbose returns true when the user has requested
        us to be more verbose than usual."""


class AndroidEngine(Protocol):
    """AndroidEngine is the engine for AndroidTask."""

    def copy_psiphon_config_files(self) -> None:
        """copy_psiphon_config_files copies the psiphon config from the
        private repository to this repository."""

    def chdir(self, dirname: str) -> str:
        """chdir changes the current directory and returns the
        previous working directory to the caller."""

    def execute(self, cmdline: List[str], inputbytes: Optional[bytes] = None) -> None:
        """execute runs the specified command line."""

    def log(self, *stuff: Any, **kwargs: Any) -> None:
        """log prints a log message on standard error."""

    def mkdir_p(self, dirname: str) -> None:
        """ mkdir_p is just like mkdir -p. """

    def prepend_to_path(self, value: str) -> None:
        """prepend_to_path prepends value to PATH using the
        proper separator for the platform."""

    def printenv(self, name: str) -> None:
        """printenv prints an environment variable."""

    def require_commands(self, commands: List[str]) -> None:
        """require_commands checks whether every provided command is available
        and fails if any of them is not available on the system."""

    def rm_rf(self, dirname: str) -> None:
        """rm_rf behaves like rm -rf."""

    def setenv(self, key: str, value: str) -> None:
        """ setenv sets an environment variable. """

    def use_android_sdk(self) -> None:
        """use_android_sdk configures the environment for the Android sdk."""

    def use_oonigo_sdk(self) -> None:
        """use_oonigo_sdk setups env to use the ooni/go SDK."""


class AndroidTask:
    """AndroidTask builds the "android" task."""

    def __init__(self, config: AndroidConfig, engine: AndroidEngine) -> None:
        self._config, self._engine = config, engine

    def run(self) -> None:
        """run runs the "android" target."""
        if self._config.goos():
            sys.exit("build: android: --goos is not supported")
        if self._config.bundle() and not self._config.sign():
            sys.exit("build: android: `-b` requires `-u EMAIL`")
        if self._config.sign():
            self._engine.require_commands(["gpg"])
        if self._config.bundle():
            self._engine.require_commands(["jar"])
        if not self._config.no_embed_psiphon():
            self._engine.copy_psiphon_config_files()
        if not self._config.no_private_sdks():
            # We use ooni/go to work around this Android issue
            # https://github.com/ooni/probe/issues/1444
            self._engine.use_oonigo_sdk()
            self._engine.use_android_sdk()
        destdir = os.path.join("MOBILE", "android")
        version = datetime.datetime.now().strftime("%Y.%m.%d-%H%M%S")
        self._engine.rm_rf(destdir)
        self._engine.mkdir_p(destdir)
        self._write_oonimkall_pom(destdir, version)
        # TODO(bassosimone): these should _require_ the environment
        self._engine.printenv("ANDROID_HOME")
        self._engine.printenv("ANDROID_NDK_HOME")
        self._engine.require_commands(["go"])
        self._go_mobile_init()
        self._engine.require_commands(["gomobile"])
        self._go_mobile_bind(destdir, version)
        if self._config.sign():
            self._sign_android_artefacts(destdir)
        if self._config.bundle():
            self._make_bundle_jar(destdir)

    def _go_mobile_init(self) -> None:
        """_go_mobile_init initializes gomobile. """
        # TODO(bassosimone): is there a way to get the latest version
        # of gomobile w/o clobbering our go.mod and go.sum?
        cmdline = ["go", "get", "-u"]
        if self._config.verbose():
            cmdline.append("-v")
        if self._config.debugging():
            cmdline.append("-x")
        cmdline.append("golang.org/x/mobile/cmd/gomobile@latest")
        self._engine.execute(cmdline)
        self._engine.execute(["gomobile", "init"])

    def _write_oonimkall_pom(self, destdir: str, version: str) -> None:
        """_write_oonimkall_pom writes the .pom file."""
        pom_template = os.path.join("MOBILE", "template.pom")
        outfile = os.path.join(destdir, "oonimkall-{}.pom".format(version))
        self._engine.log(
            "build:",
            "cat",
            shlex.join([pom_template]),
            "|",
            "sed",
            "s/@VERSION@/{}/g".format(version),
            ">",
            outfile,
        )
        if not self._config.dry_run():
            with open(pom_template, "r") as source:
                data = source.read().replace("@VERSION@", version)
                with open(outfile, "w") as dest:
                    dest.write(data)

    def _go_mobile_bind(self, destdir: str, version: str) -> None:
        """_go_mobile_bind runs gomobile bind. """
        cmdline = [
            "gomobile",
            "bind",
            "-target",
            "android",
            "-o",
            os.path.join(destdir, "oonimkall-{}.aar".format(version)),
            "-ldflags",
            "-s -w",
        ]
        if not self._config.no_embed_psiphon():
            cmdline.append("-tags=ooni_psiphon_config")
        if self._config.verbose():
            cmdline.append("-v")
        if self._config.debugging():
            cmdline.append("-x")
        cmdline.append("./pkg/oonimkall")
        self._engine.execute(cmdline)

    def _sign_android_artefacts(self, destdir: str) -> None:
        """_sign_android_artefacts signs android binaries."""
        pattern = "oonimkall*"
        for filename in glob.glob(os.path.join(destdir, pattern)):
            self._engine.execute(["gpg", "-abu", self._config.sign(), filename])

    def _make_bundle_jar(self, destdir: str) -> None:
        """_make_bundle_jar creates the bundle.jar file that is required
        to submit a new release to Maven Central."""
        cwd = self._engine.chdir(destdir)
        pattern = "oonimkall-*"
        self._engine.execute(["jar", "-cf", "bundle.jar", *glob.glob(pattern)])
        self._engine.chdir(cwd)


class MiniOONIConfig(Protocol):
    """MiniOONIConfig contains config for MiniOONITask."""

    def debugging(self) -> bool:
        """debugging returns true when the user has requested
        us to enable debugging."""

    def goos(self) -> str:
        """goos returns the GOOS for which to build."""

    def no_embed_psiphon(self) -> bool:
        """no_embed_psiphon returns true when the user has
        requested us to avoid embedding a psiphon config."""

    def no_private_sdks(self) -> bool:
        """no_private_sdks returns true when the user has
        requested us to avoid using our private SKDs, under
        the assumption that the system already contains
        suitable SDKs for building and there are environment
        variables in place pointing to them."""

    def verbose(self) -> bool:
        """verbose returns true when the user has requested
        us to be more verbose than usual."""


class MiniOONIEngine(Protocol):
    """MiniOONIEngine is the engine for MiniOONITask."""

    def copy_psiphon_config_files(self) -> None:
        """copy_psiphon_config_files copies the psiphon config from the
        private repository to this repository."""

    def execute(self, cmdline: List[str], inputbytes: Optional[bytes] = None) -> None:
        """execute runs the specified command line."""

    def log(self, *stuff: Any, **kwargs: Any) -> None:
        """log prints a log message on standard error."""

    def require_commands(self, commands: List[str]) -> None:
        """require_commands checks whether every provided command is available
        and fails if any of them is not available on the system."""

    def setenv(self, key: str, value: str) -> None:
        """ setenv sets an environment variable. """

    def unsetenv(self, key: str) -> None:
        """ unsetenv clears an environment variable. """

    def use_golang_go_sdk(self) -> None:
        """use_golang_go_sdk configures the code to use the
        golang/go SDK as our go version."""


class MiniOONITask:
    """MiniOONITask builds the "miniooni" target."""

    def __init__(self, config: MiniOONIConfig, engine: MiniOONIEngine) -> None:
        self._config, self._engine = config, engine

    def run(self) -> None:
        """run builds the "miniooni" target."""
        if not self._config.goos():
            self._engine.log("build: miniooni: no `-S GOOS` specified")
            sys.exit("See `./build miniooni --help` for more help.")
        if not self._config.no_private_sdks():
            self._engine.use_golang_go_sdk()
        if not self._config.no_embed_psiphon():
            self._engine.copy_psiphon_config_files()
        self._engine.require_commands(["go"])
        if self._config.goos() in ("darwin", "macos"):
            # TODO(bassosimone): we should notarize these files
            self._build_miniooni_darwin("amd64")
            self._build_miniooni_darwin("arm64")
        elif self._config.goos() == "linux":
            self._build_miniooni_linux("386")
            self._build_miniooni_linux("amd64")
            self._build_miniooni_linux("arm")
            self._build_miniooni_linux("arm64")
        elif self._config.goos() == "windows":
            # TODO(bassosimone): we should sign these files
            self._build_miniooni_windows("386")
            self._build_miniooni_windows("amd64")

    def _build_miniooni_darwin(self, arch: str) -> None:
        """_build_miniooni_darwin builds miniooni for darwin."""
        self._engine.setenv("CGO_ENABLED", "0")
        self._engine.setenv("GOOS", "darwin")
        self._engine.setenv("GOARCH", arch)
        cmdline = [
            "go",
            "build",
            "-o",
            os.path.join("CLI", "darwin", arch, "miniooni"),
            "-ldflags=-s -w",
        ]
        if self._config.debugging():
            cmdline.append("-x")
        if self._config.verbose():
            cmdline.append("-v")
        if not self._config.no_embed_psiphon():
            cmdline.append("-tags=ooni_psiphon_config")
        cmdline.append("./internal/cmd/miniooni")
        self._engine.execute(cmdline)
        self._engine.unsetenv("CGO_ENABLED")
        self._engine.unsetenv("GOARCH")
        self._engine.unsetenv("GOOS")

    def _build_miniooni_linux(self, arch: str) -> None:
        """_build_miniooni_windows builds miniooni for linux."""
        self._engine.setenv("CGO_ENABLED", "0")
        self._engine.setenv("GOOS", "linux")
        self._engine.setenv("GOARCH", arch)
        if arch == "arm":
            self._engine.setenv("GOARM", "7")
        cmdline = [
            "go",
            "build",
            "-o",
            os.path.join("CLI", "linux", arch, "miniooni"),
            "-ldflags=-s -w -extldflags -static",
        ]
        if self._config.debugging():
            cmdline.append("-x")
        if self._config.verbose():
            cmdline.append("-v")
        tags = "-tags=netgo"
        if not self._config.no_embed_psiphon():
            tags += ",ooni_psiphon_config"
        cmdline.append(tags)
        cmdline.append("./internal/cmd/miniooni")
        self._engine.execute(cmdline)
        self._engine.unsetenv("CGO_ENABLED")
        self._engine.unsetenv("GOARCH")
        self._engine.unsetenv("GOOS")
        if arch == "arm":
            self._engine.unsetenv("GOARM")

    def _build_miniooni_windows(self, arch: str) -> None:
        """_build_miniooni_windows builds miniooni for windows."""
        self._engine.setenv("CGO_ENABLED", "0")
        self._engine.setenv("GOOS", "windows")
        self._engine.setenv("GOARCH", arch)
        cmdline = [
            "go",
            "build",
            "-o",
            os.path.join("CLI", "windows", arch, "miniooni.exe"),
            "-ldflags=-s -w",
        ]
        if self._config.debugging():
            cmdline.append("-x")
        if self._config.verbose():
            cmdline.append("-v")
        if not self._config.no_embed_psiphon():
            cmdline.append("-tags=ooni_psiphon_config")
        cmdline.append("./internal/cmd/miniooni")
        self._engine.execute(cmdline)
        self._engine.unsetenv("CGO_ENABLED")
        self._engine.unsetenv("GOARCH")
        self._engine.unsetenv("GOOS")


class OONIProbeConfig(Protocol):
    """OONIProbeConfig contains config for OONIProbeTask."""

    def debugging(self) -> bool:
        """debugging returns true when the user has requested
        us to enable debugging."""

    def goos(self) -> str:
        """goos returns the GOOS for which to build."""

    def no_embed_psiphon(self) -> bool:
        """no_embed_psiphon returns true when the user has
        requested us to avoid embedding a psiphon config."""

    def no_private_sdks(self) -> bool:
        """no_private_sdks returns true when the user has
        requested us to avoid using our private SKDs, under
        the assumption that the system already contains
        suitable SDKs for building and there are environment
        variables in place pointing to them."""

    def verbose(self) -> bool:
        """verbose returns true when the user has requested
        us to be more verbose than usual."""


class OONIProbeEngine(Protocol):
    """OONIProbeEngine is the engine for OONIProbeTask."""

    def copy_psiphon_config_files(self) -> None:
        """copy_psiphon_config_files copies the psiphon config from the
        private repository to this repository."""

    def execute(self, cmdline: List[str], inputbytes: Optional[bytes] = None) -> None:
        """execute runs the specified command line."""

    def golang_go_version(self) -> str:
        """golang_go_version is the version of github.com/golang/go we use."""

    def log(self, *stuff: Any, **kwargs: Any) -> None:
        """log prints a log message on standard error."""

    def require_commands(self, commands: List[str]) -> None:
        """require_commands checks whether every provided command is available
        and fails if any of them is not available on the system."""

    def setenv(self, key: str, value: str) -> None:
        """ setenv sets an environment variable. """

    def unsetenv(self, key: str) -> None:
        """ unsetenv clears an environment variable. """

    def use_golang_go_sdk(self) -> None:
        """use_golang_go_sdk configures the code to use the
        golang/go SDK as our go version."""


class OONIProbeTask:
    """OONIProbeTask builds the "ooniprobe" target."""

    def __init__(self, config: OONIProbeConfig, engine: OONIProbeEngine) -> None:
        self._config, self._engine = config, engine

    def run(self) -> None:
        """run builds the "ooniprobe" target."""
        if not self._config.goos():
            self._engine.log("build: ooniprobe: no `-S GOOS` specified")
            sys.exit("See `./build ooniprobe --help` for more help.")
        if self._config.goos() == "linux":
            # Implementation note: the linux build happens inside
            # a suitable golang:${version}-alpine docker container
            # so to generate statically linked binaries
            self._build_ooniprobe_linux("386")
            self._build_ooniprobe_linux("amd64")
            self._build_ooniprobe_linux("arm")
            self._build_ooniprobe_linux("arm64")
        else:
            if not self._config.no_private_sdks():
                self._engine.use_golang_go_sdk()
            if not self._config.no_embed_psiphon():
                self._engine.copy_psiphon_config_files()
            if self._config.goos() in ("darwin", "macos"):
                self._build_ooniprobe_darwin("amd64")
                self._build_ooniprobe_darwin("arm64")
            elif self._config.goos() == "windows":
                self._build_ooniprobe_windows("386", "i686-w64-mingw32-gcc")
                self._build_ooniprobe_windows("amd64", "x86_64-w64-mingw32-gcc")
            else:
                raise NotImplementedError(self._config.goos())

    def _build_ooniprobe_darwin(self, arch: str) -> None:
        """_build_ooniprobe_darwin builds ooniprobe for darwin."""
        self._engine.require_commands(["go", "gcc"])
        self._engine.setenv("CGO_ENABLED", "1")
        self._engine.setenv("GOOS", "darwin")
        self._engine.setenv("GOARCH", arch)
        cmdline = [
            "go",
            "build",
            "-o",
            os.path.join("CLI", "darwin", arch, "ooniprobe"),
            "-ldflags=-s -w",
        ]
        if self._config.debugging():
            cmdline.append("-x")
        if self._config.verbose():
            cmdline.append("-v")
        if not self._config.no_embed_psiphon():
            cmdline.append("-tags=ooni_psiphon_config")
        cmdline.append("./cmd/ooniprobe")
        self._engine.execute(cmdline)
        self._engine.unsetenv("GOARCH")
        self._engine.unsetenv("GOOS")
        self._engine.unsetenv("CGO_ENABLED")

    def _build_ooniprobe_linux(self, arch: str) -> None:
        """_build_ooniprobe_linux builds ooniprobe for linux."""
        self._engine.require_commands(["docker"])
        cmdline = [
            "docker",
            "run",
            "--platform",
            "linux/{}".format(arch),
            "-e"
            "GOARCH={}".format(arch),
            "-it",
            "-v",
            "{}:/ooni".format(os.getcwd()),
            "-w",
            "/ooni",
            "golang:{}-alpine".format(self._engine.golang_go_version()),
            os.path.join("CLI", "linux", "build")
        ]
        self._engine.execute(cmdline)

    def _build_ooniprobe_windows(self, arch: str, gcc: str) -> None:
        """_build_ooniprobe_windows builds ooniprobe for windows."""
        self._engine.require_commands([gcc, "go"])
        self._engine.setenv("CGO_ENABLED", "1")
        self._engine.setenv("GOOS", "windows")
        self._engine.setenv("GOARCH", arch)
        self._engine.setenv("CC", gcc)
        cmdline = [
            "go",
            "build",
            "-o",
            os.path.join("CLI", "windows", arch, "ooniprobe.exe"),
            "-ldflags=-s -w",
        ]
        if self._config.debugging():
            cmdline.append("-x")
        if self._config.verbose():
            cmdline.append("-v")
        if not self._config.no_embed_psiphon():
            cmdline.append("-tags=ooni_psiphon_config")
        cmdline.append("./cmd/ooniprobe")
        self._engine.execute(cmdline)
        self._engine.unsetenv("GOARCH")
        self._engine.unsetenv("GOOS")
        self._engine.unsetenv("CGO_ENABLED")


class SetupTaskConfig(Protocol):
    """SetupTaskConfig is the config required by SetupTask."""

    def force(self) -> bool:
        """force returns true when the user has determined
        that we need to force re-initialize the state directory."""

    def no_embed_psiphon(self) -> bool:
        """no_embed_psiphon returns true when the user has
        requested us to avoid embedding a psiphon config."""

    def no_private_sdks(self) -> bool:
        """no_private_sdks returns true when the user has
        requested us to avoid using our private SKDs, under
        the assumption that the system already contains
        suitable SDKs for building and there are environment
        variables in place pointing to them."""

    def target(self) -> str:
        """target is the target we want to build."""


class SetupTaskEngine(Protocol):
    """SetupTaskEngine is the engine required by SetupTask."""

    def rm_f_cachedir(self) -> None:
        """rm_f_cachedir wipes the cache directory."""

    def maybe_init_cachedir(self) -> None:
        """maybe_init_cachedir initializes STATEDIR if needed."""

    def maybe_init_github_ooni_probe_private(self) -> None:
        """maybe_init_github_ooni_probe_private initializes the
        github.com/ooni/probe-private repository in STATEDIR."""

    def maybe_init_android_sdk(self) -> None:
        """maybe_init_android_sdk initializes the Android SDK
        if that has not been done already."""

    def maybe_init_oonigo(self) -> None:
        """maybe_init_oonigo initializes the forked ooni/go SDK."""

    def maybe_download_golang_go_sdk(self) -> None:
        """maybe_download_golang_go_sdk downloads the golang/go SDK if needed."""


class SetupTask:
    """SetupTask sets the cache directory up."""

    def __init__(self, config: SetupTaskConfig, engine: SetupTaskEngine) -> None:
        self._config, self._engine = config, engine

    def run(self) -> None:
        """run initializes the cache directory, if needed."""
        if self._config.force():
            self._engine.rm_f_cachedir()
        if not self._config.no_private_sdks():
            self._engine.maybe_init_cachedir()
            if not self._config.no_embed_psiphon():
                self._engine.maybe_init_github_ooni_probe_private()
            self._engine.maybe_download_golang_go_sdk()
            if self._config.target() == "android":
                # On Android we use our ooni/go fork of golang/go to
                # work around https://github.com/ooni/probe/issues/1444
                self._engine.maybe_init_android_sdk()
                self._engine.maybe_init_oonigo()


class Engine:
    """Engine is the core engine of this program."""

    def __init__(self, dry_run: bool) -> None:
        self._dry_run = dry_run
        self._sconf = StaticConfig()  # above to simplify updating

    def _android_tools_os(self) -> str:
        system = platform.system()
        if system == "Linux":
            return "linux"
        if system == "Darwin":
            return "mac"
        raise RuntimeError(system)

    def _goos(self) -> str:
        system = platform.system()
        if system == "Linux":
            return "linux"
        if system == "Darwin":
            return "darwin"
        raise RuntimeError(system)

    def _goarch(self) -> str:
        machine = platform.machine()
        if machine in ("arm64", "arm", "386", "amd64"):
            return machine
        if machine in ("x86", "i386"):
            return "386"
        if machine == "x86_64":
            return "amd64"
        if machine == "aarch64":
            return "arm64"
        raise RuntimeError(machine)

    def golang_go_version(self) -> str:
        return self._sconf.golang_go_version()

    def log(self, *stuff: Any, **kwargs: Any) -> None:
        print(*stuff, file=sys.stderr, **kwargs)

    def execute(self, cmdline: List[str], inputbytes: Optional[bytes] = None) -> None:
        self.log("build:", shlex.join(cmdline))
        if not self._dry_run:
            subprocess.run(cmdline, check=True, input=inputbytes)

    def rm_rf(self, dirname: str) -> None:
        self.log("build:", shlex.join(["rm", "-rf", dirname]))
        if not self._dry_run:
            shutil.rmtree(dirname, ignore_errors=True)

    def _movefile(self, src: str, dest: str) -> None:
        self.log("build:", shlex.join(["mv", src, dest]))
        if not self._dry_run:
            shutil.move(src, dest)

    def _copyfile(self, src: str, dest: str) -> None:
        self.log("build:", shlex.join(["cp", src, dest]))
        if not self._dry_run:
            shutil.copy(src, dest)

    def chdir(self, dirname: str) -> str:
        cwd = os.getcwd()
        self.log("build:", shlex.join(["cd", dirname]))
        if not self._dry_run:
            os.chdir(dirname)
        return cwd

    def mkdir_p(self, dirname: str) -> None:
        self.log("build:", shlex.join(["mkdir", "-p", dirname]))
        if not self._dry_run:
            os.makedirs(dirname)

    def setenv(self, key: str, value: str) -> None:
        self.log("build:", shlex.join(["export", "{}={}".format(key, value)]))
        os.environ[key] = value

    def unsetenv(self, key: str) -> None:
        self.log("build:", shlex.join(["unset", key]))
        os.environ.pop(key)

    def prepend_to_path(self, value: str) -> None:
        cur = os.environ["PATH"]
        self.setenv("PATH", value + os.pathsep + cur)

    def use_golang_go_sdk(self) -> None:
        self.prepend_to_path(
            os.path.join(self._sconf.golang_go_root_dir(), "go", "bin")
        )

    def printenv(self, name: str) -> None:
        self.log("build: echo ${}".format(name))
        self.log(os.environ.get(name, ""))

    def _check_for_command(self, executable: str) -> Optional[str]:
        # command -v is in POSIX 2008: https://stackoverflow.com/a/34572831
        self.log("build: echo -n 'checking for {}... '".format(executable))
        self.log("build: command -v %s || { echo 'not found'; exit 1; }" % executable)
        fullpath = shutil.which(executable)
        if not fullpath:
            self.log("checking for {}... not found".format(executable))
            return None
        self.log("checking for {}... {}".format(executable, fullpath))
        return fullpath

    def require_commands(self, commands: List[str]) -> None:
        for cmd in commands:
            if not self._check_for_command(cmd):
                sys.exit(1)

    def copy_psiphon_config_files(self) -> None:
        for name in ("psiphon-config.json.age", "psiphon-config.key"):
            source = os.path.join(self._sconf.probe_private_source_dir(), name)
            dst = os.path.join("internal", "engine", name)
            self._copyfile(source, dst)

    def _fix_gocache_perms(self) -> None:
        """_fix_gocache_perms makes sure we can delete all files in a tree. This
        is a precondition for being able to delete files in the gocache, which
        are non writable by default."""
        # This is what we're morally doing. Due to the way in which chmod
        # works in Python, in reality we force 0700 and 0600 but that's just
        # a minor implementation detail and logging is still ~accurate.
        self.log(
            "build:",
            "find",
            shlex.join([self._sconf.cachedir()]),  # just in case it has spaces
            "-exec",
            "chmod",
            "+w",
            "{}",
            "\\;",
        )
        for dirpath, _, filenames in os.walk(self._sconf.cachedir()):
            self.log("build: chmod 700", dirpath)
            if not self._dry_run:
                os.chmod(dirpath, 0o700)
            for filename in filenames:
                fpath = os.path.join(dirpath, filename)
                self.log("build: chmod 600", fpath)
                if not self._dry_run:
                    os.chmod(fpath, 0o600)

    def maybe_init_cachedir(self) -> None:
        if not os.path.isdir(self._sconf.cachedir()):
            self.mkdir_p(self._sconf.cachedir())
            self._write_simple_readme()

    def rm_f_cachedir(self) -> None:
        self._fix_gocache_perms()
        self.rm_rf(self._sconf.cachedir())

    def _write_simple_readme(self) -> None:
        """write_simple_readme adds a simple readme to the STATEDIR
        directory so that a user understands what they see."""
        readme = os.path.join(self._sconf.cachedir(), "README.txt")
        text = "Generated and managed by github.com/ooni/probe-cli build script."
        self.log("build:", "echo", shlex.join([text]), ">", shlex.join([readme]))
        if not self._dry_run:
            with open(readme, "w") as filep:
                filep.write(text + "\n")

    def maybe_init_github_ooni_probe_private(self) -> None:
        """maybe_init_github_ooni_probe_private initializes the
        github.com/ooni/probe-private repository in the cache dir."""
        if not os.path.isdir(self._sconf.probe_private_source_dir()):
            self._clone_github_ooni_probe_private()

    def _clone_github_ooni_probe_private(self) -> None:
        self.require_commands(["git"])
        self.execute(
            [
                "git",
                "clone",
                self._sconf.probe_private_repo_url(),
                self._sconf.probe_private_source_dir(),
            ]
        )

    def _download_android_cli_tools(self) -> None:
        # TODO(bassosimone): add support for Windows?
        expected = self._sconf.android_cmdline_tools_sha256()[self._goos()]
        filename = "commandlinetools-{}-{}_latest.zip".format(
            self._android_tools_os(),
            self._sconf.android_cmdline_tools_version(),
        )
        self.mkdir_p(self._sconf.android_sdk_root_dir())
        cwd = self.chdir(self._sconf.android_sdk_root_dir())
        url = "https://dl.google.com/android/repository/{}".format(filename)
        self._download_and_verify(url, expected, filename)
        self.log("build: unzip", filename)
        if not self._dry_run:
            with zipfile.ZipFile(filename, "r") as filep:
                filep.extractall()
        # See https://stackoverflow.com/a/61176718 to understand why
        # we're doing this directory dance :^)
        self._movefile("cmdline-tools", self._sconf.android_cmdline_tools_version())
        self.mkdir_p("cmdline-tools")
        self._movefile(self._sconf.android_cmdline_tools_version(), "cmdline-tools")
        self.chdir(cwd)
        self._fix_android_cli_tools_perms()

    def _download_and_verify(self, url: str, checksum: str, outfile: str) -> None:
        self.log("build: wget", url)
        self.log(
            "build:",
            "digest=`",
            "cat",
            shlex.join([outfile]),
            "|",
            "shasum",
            "-a",
            "256",
            "|",
            "awk",
            "'{print $1}'",
            "`",
        )
        self.log(
            "build:", "test", "$digest", "=", "{}".format(checksum), "||", "exit 1"
        )
        if self._dry_run:
            return
        resp = urllib.request.urlopen(url)
        data = resp.read()
        digest = hashlib.sha256(data).hexdigest()
        if digest != checksum:
            raise RuntimeError(
                "digest mismatch: want {} and got {}".format(checksum, digest)
            )
        with open(outfile, "wb") as filep:
            filep.write(data)

    def _fix_android_cli_tools_perms(self):
        """fix_android_cli_tools_perms fixes the Android CLI perms so
        that we can actually execute sdkmanager. There is a
        bug in the way in which Python's zipfile extracts the
        binaries that causes the executable bit to be lost
        as documented in https://bugs.python.org/issue15795."""
        toolsdir = os.path.join(
            self._sconf.android_sdk_root_dir(),
            "cmdline-tools",
            self._sconf.android_cmdline_tools_version(),
            "bin",
        )
        # Reasonably accurate logging statement
        self.log(
            "build:",
            "find",
            shlex.join([toolsdir]),
            "-type",
            "-f",
            "-exec",
            "chmod",
            "+x",
            "{}",
            "\\;",
        )
        for dirpath, _, filenames in os.walk(toolsdir):
            for filename in filenames:
                fpath = os.path.join(dirpath, filename)
                self.log("build: chmod 700", fpath)
                if not self._dry_run:
                    os.chmod(fpath, 0o700)

    def _install_android_sdk_and_ndk(self) -> None:
        # TODO(bassosimone): how to implement updates?
        self.require_commands(["java"])
        self.printenv("JAVA_HOME")
        sdkmanager = os.path.join(
            self._sconf.android_sdk_root_dir(),
            "cmdline-tools",
            self._sconf.android_cmdline_tools_version(),
            "bin",
            "sdkmanager",
        )
        args = [
            sdkmanager,
            "--install",
            "build-tools;{}".format(self._sconf.android_build_tools_version()),
            "platforms;{}".format(self._sconf.android_platform_version()),
            "ndk;{}".format(self._sconf.android_ndk_version()),
        ]
        self.execute(args, inputbytes=b"Y\n")

    def maybe_init_android_sdk(self) -> None:
        """maybe_init_android_sdk initializes the Android SDK."""
        if not os.path.isdir(self._sconf.android_sdk_root_dir()):
            self._download_android_cli_tools()
            self._install_android_sdk_and_ndk()

    def maybe_download_golang_go_sdk(self) -> None:
        """maybe_download_golang_go_sdk downloads the golang/go SDK if needed."""
        if not os.path.isdir(self._sconf.golang_go_root_dir()):
            self._download_golang_go_sdk()

    def _download_golang_go_sdk(self) -> None:
        # TODO(bassosimone): add support for Windows?
        osname, archname = self._goos(), self._goarch()
        expected = self._sconf.golang_go_sha256()[osname][archname]
        filename = "go{}.{}-{}.tar.gz".format(
            self._sconf.golang_go_version(), osname, archname
        )
        self.mkdir_p(self._sconf.golang_go_root_dir())
        cwd = self.chdir(self._sconf.golang_go_root_dir())
        url = "https://golang.org/dl/{}".format(filename)
        self._download_and_verify(url, expected, filename)
        self.log("build: tar -xf", filename)
        if not self._dry_run:
            with tarfile.open(filename) as filep:
                filep.extractall()
        self.chdir(cwd)

    def _oonigo_clone(self) -> None:
        self.require_commands(["git"])
        self.execute(
            [
                "git",
                "clone",
                "-b",
                self._sconf.oonigo_branch(),
                "--single-branch",
                "--depth",
                "8",
                self._sconf.oonigo_repo_url(),
                self._sconf.oonigo_source_dir(),
            ]
        )

    def _oonigo_make(self) -> None:
        self.require_commands(["bash"])
        # This environment variable forces using a specific Go to bootstrap
        self.setenv(
            "GOROOT_BOOTSTRAP", os.path.join(self._sconf.golang_go_root_dir(), "go")
        )
        cwd = self.chdir(os.path.join(self._sconf.oonigo_source_dir(), "src"))
        self.execute(["./make.bash"])
        self.chdir(cwd)

    def maybe_init_oonigo(self) -> None:
        """maybe_init_oonigo initializes our Go fork."""
        if not os.path.isdir(self._sconf.oonigo_source_dir()):
            self._oonigo_clone()
            self._oonigo_make()

    def use_android_sdk(self) -> None:
        """use_android_sdk configures the environment for the Android sdk."""
        self.setenv("ANDROID_HOME", self._sconf.android_sdk_root_dir())
        self.setenv(
            "ANDROID_NDK_HOME",
            os.path.join(
                self._sconf.android_sdk_root_dir(),
                "ndk",
                self._sconf.android_ndk_version(),
            ),
        )

    def use_oonigo_sdk(self) -> None:
        """use_oonigo_sdk setups env to use the ooni/go SDK."""
        self.prepend_to_path(self._sconf.oonigo_bin_dir())
        self.prepend_to_path(os.path.join(self._sconf.gopath(), "bin"))
        self.setenv("GOPATH", self._sconf.gopath())


class Config:
    """ Config provides config from CLI options."""

    @classmethod
    def parse(cls, targets: List[str]) -> Config:
        """parse parses command line options and returns a
        suitable configuration object."""
        conf = cls()
        conf._parse(targets)
        return conf

    def __init__(self) -> None:
        self._bundle = False
        self._debugging = False
        self._dry_run = False
        self._force = False
        self._goos = ""
        self._no_embed_psiphon = False
        self._no_private_sdks = False
        self._sign = ""
        self._target = ""
        self._verbose = False

    # Implement the various FooConfig protocols
    # defined above.

    def bundle(self) -> bool:
        return self._bundle

    def debugging(self) -> bool:
        return self._debugging

    def dry_run(self) -> bool:
        return self._dry_run

    def force(self) -> bool:
        return self._force

    def goos(self) -> str:
        return self._goos

    def no_embed_psiphon(self) -> bool:
        return self._no_embed_psiphon

    def no_private_sdks(self) -> bool:
        return self._no_private_sdks

    def sign(self) -> str:
        return self._sign

    def target(self) -> str:
        return self._target

    def verbose(self) -> bool:
        return self._verbose

    # Parse command line options. Here we're using getopt
    # because I didn't like argparse's output.

    __usage_string = """\
usage: ./build [-nf] -t ooniprobe -S GOOS [-N {psiphon|sdks}] [-vx]
       ./build [-nf] -t android           [-N {psiphon|sdks}] [-vx] [[-b] -u EMAIL]
       ./build [-nf] -t miniooni  -S GOOS [-N {psiphon|skds}] [-vx]
       ./build [-h]
       ./build --help
"""

    __help_string = """
The `./build -t ooniprobe` form of the command builds ./cmd/ooniprobe
for the GOOS selected with the `-S` flag. Valid values are `darwin`,
`linux`, and `windows`. We also recognize `macos` as an alias for `darwin`.

The `./build -t android` form of the command builds ./pkg/oonimkall
for the arm, arm64, 386, and amd64 Android architectures.

The `./build -t miniooni` form of the command builds ./internal/cmd/miniooni
for the GOOS selected with the `-S` flag. We support the same GOOS
values that we support for building ooniprobe.

The `./build --help` form of the command prints this help message. The
program invoked with no arguments or with `-h` as argument emits a terse
help message instead.

The `-n` flag enables a dry run. The command will not execute any real
operation, but will print the operations that would be executed.

The `-f` flag wipes the cache directory ($HOME/.ooniprobe-build) before
executing any other operation. We use the cache directory to store the
private Go and Android SDKs used to build. The SDKs are lazily downloaded
the first time that they are required by a specific build.

The `-N` flag allows to disable features. The `-N psiphon` flag means
that we will not attempt top clone the git@github.com:ooni/probe-private
respository and use it to configure the psiphon config file to be used
by the generated binaries. Use this flag if you do not have privileges to
clone private repositories in the OONI organization.

The `-N sdks` flag means that rather than using private Go and Android
SDKs in the cache directory, you want this command to use the "go" binary
available in PATH and the Android SDK pointed to by the ANDROID_HOME
and the ANDROID_NDK_HOME environment variables.

The `-v` and `-x` flags are passed directly to the Go compiler. They
turn on, respectively, verbose and debug messages.

The `-b` and `-u` flag are used by Android builds only. The `-u` flag
specifies the PGP identity with which to sign the build artefacts, while
the `-b` flag controls whether to generate a `bundle.jar` file with the
artefacts and the signatures. The `bundle.jar` file is what you need
to upload a new release at Maven Central. It is an error to specify the
`-b` flag without specifying the `-u` flag.
"""

    @classmethod
    def _wrong_usage(cls, err: str) -> NoReturn:
        sys.stderr.write("error: {}\n".format(err))
        sys.stderr.write(cls.__usage_string)
        sys.exit(1)

    def _parse(self, targets: List[str]):
        try:
            opts, args = getopt.getopt(sys.argv[1:], "bfhN:nS:t:u:vx", ["help"])
        except getopt.GetoptError as err:
            self._wrong_usage(err.msg)
        if args:
            self._wrong_usage("unexpected number of positional arguments")

        for key, value in opts:
            if key == "-b":
                self._bundle = True
            elif key == "-f":
                self._force = True
            elif key == "-h":  # terse help
                sys.stdout.write(self.__usage_string)
                sys.exit(0)
            elif key == "--help":
                sys.stdout.write(self.__usage_string)
                sys.stdout.write(self.__help_string)
                sys.exit(0)
            elif key == "-N":
                if value == "psiphon":
                    self._no_embed_psiphon = True
                elif value == "sdks":
                    self._no_private_sdks = True
                else:
                    self._wrong_usage("invalid argument for -N: {}".format(value))
            elif key == "-n":
                self._dry_run = True
            elif key == "-S":
                self._goos = value
            elif key == "-t":
                self._target = value
            elif key == "-u":
                self._sign = value
            elif key == "-v":
                self._verbose = True
            elif key == "-x":
                self._debugging = True
            else:
                raise RuntimeError(key)

        if self._target == "":  # ./build prints terse help
            sys.stdout.write(self.__usage_string)
            sys.exit(0)

        for target in targets:
            if target == self._target:
                break
        else:
            self._wrong_usage("unknown target: {}".format(self._target))


class Task(Protocol):
    """Task is a generic task."""

    def run(self) -> None:
        """run runs the task."""


# TARGETS maps every target task name to a task constructor
TARGETS: Dict[str, Callable[[Config, Engine], Task]] = {
    "ooniprobe": OONIProbeTask,
    "android": AndroidTask,
    "miniooni": MiniOONITask,
}


def main() -> None:
    """ Main function. """
    config = Config.parse(list(TARGETS.keys()))
    engine = Engine(config.dry_run())
    setup_task = SetupTask(config, engine)
    setup_task.run()
    # We already checked that we have a valid target in Config.parse
    build_task = TARGETS[config.target()](config, engine)
    build_task.run()


if __name__ == "__main__":
    main()
