#!/usr/bin/env python3

""" Build script for ooniprobe. You can get documentation regarding
its usage by running `./build help`. """

import argparse
import datetime
import glob
import hashlib
import os
import shlex
import shutil
import subprocess
import sys
import tarfile
import urllib.request
import zipfile

# STATEDIR is the root directory where we store useful state
STATEDIR = os.path.join(os.path.expandvars("${HOME}"), ".ooniprobe-build")

# ANDROID_CMDLINE_TOOLS_SHA256 contains the SHA256 of the version
# of the Android cmdline tools that we will download.
ANDROID_CMDLINE_TOOLS_SHA256 = (
    "87f6dcf41d4e642e37ba03cb2e387a542aa0bd73cb689a9e7152aad40a6e7a08"
)

# ANDROID_CMDLINE_TOOLS_VERSION contains the version of the
# command line tools that we will download.
ANDROID_CMDLINE_TOOLS_VERSION = "6858069"

# ANDROID_NDK_VERSION contains the Android NDK version.
ANDROID_NDK_VERSION = "22.1.7171670"

# ANDROID_PLATFORM_VERSION is the platform version to install.
ANDROID_PLATFORM_VERSION = "android-30"

# ANDROID_SDK_ROOT_DIR is the directory where we install
# the latest Android SDK
ANDROID_SDK_ROOT_DIR = os.path.join(STATEDIR, "sdk", "android.com")

# GO_OONIGO_SOURCE_DIR is the directory inside which we clone our Go fork
GO_OONIGO_SOURCE_DIR = os.path.join(STATEDIR, "sdk", "github.com", "ooni", "go")

# GO_OONIGO_REPO_URL is the repository containing our Go fork
GO_OONIGO_REPO_URL = "https://github.com/ooni/go"

# GO_OONIGO_BRANCH is the branch of our Go fork to checkout
GO_OONIGO_BRANCH = "ooni"

# GO_OONIGO_BIN_DIR is the directory where the "go" binary compiled from
# our Go fork will be available after `./build init`.
GO_OONIGO_BIN_DIR = os.path.join(GO_OONIGO_SOURCE_DIR, "bin")

# GO_BOOTSTRAP_ROOT_DIR is the directory in which we copy
# the binary distribution of golang we use to boostrap our
# own Go fork. The design choice to bootstrap our fork using
# a binary distribution of Go means that there is no need
# to have a working Go binary on the system. The most tangible
# advantage of this design is that we can be sure that no
# default system configuration causes the default "system" go
# to be used instead of our fork, for some reason.
GO_BOOTSTRAP_ROOT_DIR = os.path.join(STATEDIR, "sdk", "golang.org")

# GOPATH is the directory that we will use as a GOPATH when
# using our own fork of Go. This choice ensures that the
# binaries we will be using are separate from the default
# ones, which typically live in $HOME/go. Even though we're
# prepared for a system where "go" is not in PATH, a tool
# like VSCode is capable to downloading and using a specific
# version of Go, which will put its data in $HOME/go.
GOPATH = os.path.join(STATEDIR, "gopath")

# POM_TEMPLATE is the template of the .pom file that we
# include inside the bundle.jar for Maven Central.
POM_TEMPLATE = r"""<?xml version="1.0" encoding="UTF-8"?>
<project xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd" xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <modelVersion>4.0.0</modelVersion>

  <groupId>org.ooni</groupId>
  <artifactId>oonimkall</artifactId>
  <version>@VERSION@</version>
  <packaging>aar</packaging>

  <name>oonimkall</name>
  <description>OONI Probe Library for Android</description>
  <url>https://github.com/ooni/probe-cli</url>

  <licenses>
    <license>
      <name>The 3-Clause BSD License</name>
      <url>https://opensource.org/licenses/BSD-3-Clause</url>
      <distribution>repo</distribution>
    </license>
  </licenses>

  <scm>
    <url>https://github.com/ooni/probe-engine</url>
    <connection>https://github.com/ooni/probe-engine.git</connection>
  </scm>

  <developers>
    <developer>
      <name>Simone Basso</name>
      <email>simone@openobservatory.org</email>
      <roles>
        <role>Core developer</role>
      </roles>
      <timezone>Europe/Rome</timezone>
    </developer>
  </developers>

</project>
"""

# PRIVATE_REPO_URL is the URL of the repo containing private
# information required by some build configurations
PRIVATE_REPO_URL = "git@github.com:ooni/probe-private"

# PRIVATE_SOURCE_DIR is the directory where we clone the
# repository containing private configurations
PRIVATE_SOURCE_DIR = os.path.join(
    STATEDIR, "sdk", "github.com", "ooni", "probe-private"
)

#
# Utilities
#
# This section of the script contains utility functions.
#


def log(*stuff, **kwargs) -> None:
    """log prints a log message on standard error. The arguments
    contains the stuff that you wanna log."""
    print(*stuff, file=sys.stderr, **kwargs)


def execute(cmdline: list[str], input: str = None) -> None:
    """execute runs the specified command line, which must be
    a list of strings, where the first string is the command."""
    log("build:", shlex.join(cmdline))
    subprocess.run(cmdline, check=True, input=input)
    log('build: command "{}" terminated successfully'.format(cmdline[0]))


def rmtree(dir: str) -> None:
    """rmtree deletes a specified directory tree. The behavior
    of this function is just like rm -rf."""
    log("build: rm -rf", dir)
    shutil.rmtree(dir, ignore_errors=True)


def mv(src: str, dest: str) -> None:
    """mv renames a file or directory."""
    log("build: mv", src, dest)
    shutil.move(src, dest)


def cp(src: str, dest: str) -> None:
    """cp copies a file."""
    log("build: cp", src, dest)
    shutil.copy(src, dest)


def chdir(dir: str) -> None:
    """chdir changes the current directory and returns the
    previous working directory to the caller."""
    cwd = os.getcwd()
    log("build: cd", dir)
    os.chdir(dir)
    return cwd


def makedirs(dir: str) -> None:
    """ makedirs is just like mkdir -p. """
    log("build: mkdir -p", dir)
    os.makedirs(dir)


def setenv(key: str, value: str) -> None:
    """ setenv sets an environment variable. """
    log("build:", shlex.join(["export", "{}={}".format(key, value)]))
    os.environ[key] = value


def unsetenv(key: str) -> None:
    """ unsetenv clears an environment variable. """
    log("build:", shlex.join(["unset", key]))
    os.environ.pop(key)


def prepend_to_path(value: str) -> None:
    """prepend_to_path prepends value to PATH using the
    proper separator for the platform."""
    # TODO(bassosimone): add support for Windows?
    cur = os.environ["PATH"]
    setenv("PATH", value + ":" + cur)


def setupenv() -> None:
    """setupenv setups environment variables to use
    the SDKs that we have downloaded with "init"."""
    prepend_to_path(GO_OONIGO_BIN_DIR)
    prepend_to_path(os.path.join(GOPATH, "bin"))
    setenv("GOPATH", GOPATH)
    setenv("ANDROID_HOME", ANDROID_SDK_ROOT_DIR)
    setenv(
        "ANDROID_NDK_HOME",
        os.path.join(ANDROID_SDK_ROOT_DIR, "ndk", ANDROID_NDK_VERSION),
    )


def which(executable: str) -> str:
    """which returns the path of the executable named executable, if
    existing. Otherwise it returns None."""
    fullpath = shutil.which(executable)
    if not fullpath:
        log("checking for {}... not found".format(executable))
        return None
    log("checking for {}... {}".format(executable, fullpath))
    return fullpath


def require(commands: list[str]) -> None:
    """require checks whether every provided command is available
    and fails if any of them is not available"""
    for cmd in commands:
        if not which(cmd):
            sys.exit("fatal: cannot find {} command".format(cmd))


def copypsiphonconfig() -> None:
    """copypsiphonconfig copies the psiphon config from the
    private repository to this repository."""
    for name in ("psiphon-config.json.age", "psiphon-config.key"):
        source = os.path.join(PRIVATE_SOURCE_DIR, name)
        dst = os.path.join("internal", "engine", name)
        cp(source, dst)


#
# Android
#
# This section of the script contains the implementation
# of the "android" subcommand.
#


def doandroid(args: argparse.Namespace) -> None:
    """doandroid implements the android subcommand."""
    if args.bundle and not args.sign:
        sys.exit("build: android: --bundle requires --sign=EMAIL")
    if args.sign:
        require(["gpg"])
    if args.bundle:
        require(["jar"])
    copypsiphonconfig()
    setupenv()
    which("go")
    destdir = os.path.join("MOBILE", "android")
    v = datetime.datetime.now().strftime("%Y.%m.%d-%H%M%S")
    rmtree(destdir)
    makedirs(destdir)
    gomobileinit(args)
    which("gomobile")
    writepom(destdir, v)
    gomobilebind(args, destdir, v)
    signandroid(args, destdir)
    makebundlejar(args, destdir)


def makebundlejar(args: argparse.Namespace, destdir: str) -> None:
    """makebundlejar creates the bundle.jar file that is required
    to submit a new release to Maven Central."""
    if args.bundle:
        cwd = chdir(destdir)
        pattern = "oonimkall-*"
        execute(["jar", "-cf", "bundle.jar", *glob.glob(pattern)])
        chdir(cwd)


def signandroid(args: argparse.Namespace, destdir: str) -> None:
    """signandroid signs android binaries."""
    if args.sign:
        pattern = "oonimkall*"
        for filename in glob.glob(os.path.join(destdir, pattern)):
            execute(["gpg", "-abu", args.sign, filename])


def writepom(destdir: str, v: str) -> None:
    """ writepom writes the .pom file. """
    data = POM_TEMPLATE.replace("@VERSION@", v)
    outfile = os.path.join(destdir, "oonimkall-{}.pom".format(v))
    with open(outfile, "w") as filep:
        filep.write(data)


def gomobileinit(args: argparse.Namespace) -> None:
    """gomobileinit initializes gomobile. """
    # TODO(bassosimone): is there a way to get the latest version
    # of gomobile w/o clobbering our go.mod and go.sum?
    cmdline = ["go", "get", "-u"]
    if args.verbose:
        cmdline.append("-v")
    if args.x:
        cmdline.append("-x")
    cmdline.append("golang.org/x/mobile/cmd/gomobile@latest")
    execute(cmdline)
    execute(["gomobile", "init"])  # this compiles OpenAL


def gomobilebind(args: argparse.Namespace, destdir: str, v: str) -> None:
    """gomobilebind runs gomobile bind. """
    cmdline = [
        "gomobile",
        "bind",
        "-target",
        "android",
        "-o",
        os.path.join(destdir, "oonimkall-{}.aar".format(v)),
        "-ldflags",
        "-s -w",
    ]
    cmdline.append("-tags")
    cmdline.append("ooni_psiphon_config")
    if args.verbose:
        cmdline.append("-v")
    if args.x:
        cmdline.append("-x")
    cmdline.append("./pkg/oonimkall")
    execute(cmdline)


#
# Init
#
# This section of the script contains the implementation
# of the "init" subcommand.
#


def clonego() -> None:
    """ clonego clones our go fork. """
    execute(
        [
            "git",
            "clone",
            "-b",
            GO_OONIGO_BRANCH,
            "--single-branch",
            "--depth",
            "8",
            GO_OONIGO_REPO_URL,
            GO_OONIGO_SOURCE_DIR,
        ]
    )


def makego() -> None:
    """makego builds our go fork using as bootstrap the binary
    distribution of Go that we've already downloaded."""
    setenv("GOROOT_BOOTSTRAP", os.path.join(GO_BOOTSTRAP_ROOT_DIR, "go"))
    cwd = chdir(os.path.join(GO_OONIGO_SOURCE_DIR, "src"))
    execute(["./make.bash"])
    chdir(cwd)


def fixandroidcliperms():
    """fixandroidcliperms fixes the Android CLI perms so
    that we can actually execute sdkmanager. There is a
    bug in the way in which Python's zipfile extracts the
    binaries that causes the executable bit to be lost
    as documented in https://bugs.python.org/issue15795."""
    dir = os.path.join(
        ANDROID_SDK_ROOT_DIR,
        "cmdline-tools",
        ANDROID_CMDLINE_TOOLS_VERSION,
        "bin",
    )
    for dirpath, _, filenames in os.walk(dir):
        for filename in filenames:
            fpath = os.path.join(dirpath, filename)
            log("build: chmod 700", fpath)
            os.chmod(fpath, 0o700)


def fixtreeperms(dir: str) -> None:
    """fixtreeperms makes sure we can delete all files in a tree. This
    is a precondition for being able to delete files in the gocache, which
    are non writable by default."""
    for dirpath, _, filenames in os.walk(dir):
        log("build: chmod 700", dirpath)
        os.chmod(dirpath, 0o700)
        for filename in filenames:
            fpath = os.path.join(dirpath, filename)
            log("build: chmod 600", fpath)
            os.chmod(fpath, 0o600)


def getbootstrapgo() -> None:
    """getbootstrapgo downloads the binary Go distribution for the
    current system. We will use such a distribution to bootstrap
    the build of our modified fork of Go."""
    # TODO(bassosimone): add support for macOS. Can we also add
    # support for Windows or is this too complicated?
    expected = "951a3c7c6ce4e56ad883f97d9db74d3d6d80d5fec77455c6ada6c1f7ac4776d2"
    filename = "go1.16.3.linux-amd64.tar.gz"
    makedirs(GO_BOOTSTRAP_ROOT_DIR)
    cwd = chdir(GO_BOOTSTRAP_ROOT_DIR)
    url = "https://golang.org/dl/{}".format(filename)
    log("build: wget", url)
    resp = urllib.request.urlopen(url)
    data = resp.read()
    digest = hashlib.sha256(data).hexdigest()
    if digest != expected:
        raise RuntimeError(
            "digest mismatch: want {} and got {}".format(expected, digest)
        )
    with open(filename, "wb") as filep:
        filep.write(data)
    log("build: tar -xf", filename)
    with tarfile.open(filename) as filep:
        filep.extractall()
    chdir(cwd)


def writesimplereadme(dir: str) -> None:
    """writesimplereadme adds a simple readme to the STATEDIR
    directory so that a user understands what they see."""
    readme = os.path.join(dir, "README.txt")
    with open(readme, "w") as filep:
        filep.write("This directory contains state used to build the\n")
        filep.write("github.com/ooni/probe-cli repository and generated\n")
        filep.write("by the `./build` script of such repository.\n")


def getandroidclitools() -> None:
    """ getandroidcli downloads android CLI tools."""
    # TODO(bassosimone): add support for macOS. Can we also add
    # support for Windows or is this too complicated?
    expected = ANDROID_CMDLINE_TOOLS_SHA256
    filename = "commandlinetools-linux-{}_latest.zip".format(
        ANDROID_CMDLINE_TOOLS_VERSION
    )
    makedirs(ANDROID_SDK_ROOT_DIR)
    cwd = chdir(ANDROID_SDK_ROOT_DIR)
    url = "https://dl.google.com/android/repository/{}".format(filename)
    log("build: wget", url)
    resp = urllib.request.urlopen(url)
    data = resp.read()
    digest = hashlib.sha256(data).hexdigest()
    if digest != expected:
        raise RuntimeError(
            "digest mismatch: want {} and got {}".format(expected, digest)
        )
    with open(filename, "wb") as filep:
        filep.write(data)
    log("build: unzip", filename)
    with zipfile.ZipFile(filename, "r") as filep:
        filep.extractall()
    # See https://stackoverflow.com/a/61176718
    mv("cmdline-tools", ANDROID_CMDLINE_TOOLS_VERSION)
    makedirs("cmdline-tools")
    mv(ANDROID_CMDLINE_TOOLS_VERSION, "cmdline-tools")
    chdir(cwd)
    fixandroidcliperms()


def installsdkndk() -> None:
    """installsdkndk installs Android's SDK and NDK."""
    sdkmanager = os.path.join(
        ANDROID_SDK_ROOT_DIR,
        "cmdline-tools",
        ANDROID_CMDLINE_TOOLS_VERSION,
        "bin",
        "sdkmanager",
    )
    args = [
        sdkmanager,
        "--install",
        "build-tools;29.0.3",
        "platforms;{}".format(ANDROID_PLATFORM_VERSION),
        "ndk;{}".format(ANDROID_NDK_VERSION),
    ]
    execute(args, input=b"Y\n")


def cloneprivaterepo(dir: str) -> None:
    """cloneprivaterepo clones the private repository
    containing private information required by some
    specific build configurations."""
    execute(
        [
            "git",
            "clone",
            PRIVATE_REPO_URL,
            PRIVATE_SOURCE_DIR,
        ]
    )


def doinit() -> None:
    """doinit implements the init subcommand."""
    require(["bash", "git", "java"])
    fixtreeperms(STATEDIR)
    rmtree(STATEDIR)
    makedirs(STATEDIR)
    writesimplereadme(STATEDIR)
    cloneprivaterepo(STATEDIR)
    getandroidclitools()
    installsdkndk()
    getbootstrapgo()
    clonego()
    makego()


#
# Miniooni
#
# This section implements the "miniooni" subcommand
#


def dominiooni(args: argparse.Namespace) -> None:
    """dominiooni implements the "miniooni" subcommand."""
    if not args.no_ooni_go:
        setupenv()
    if not args.no_embed_psiphon:
        copypsiphonconfig()
    which("go")
    if args.miniooni_goos in ("darwin", "macos"):
        build_miniooni_darwin(args, "amd64")
        build_miniooni_darwin(args, "arm64")
    elif args.miniooni_goos == "linux":
        build_miniooni_linux(args, "386")
        build_miniooni_linux(args, "amd64")
        build_miniooni_linux(args, "arm")
        build_miniooni_linux(args, "arm64")
    elif args.miniooni_goos == "windows":
        build_miniooni_windows(args, "386")
        build_miniooni_windows(args, "amd64")
    else:
        log("build: miniooni: no target arch specified")
        sys.exit("See `./build miniooni --help` for more help.")


def build_miniooni_darwin(args, arch):
    """build_miniooni_darwin builds miniooni for darwin."""
    setenv("GOOS", "darwin")
    setenv("GOARCH", arch)
    cmdline = [
        "go",
        "build",
        "-o",
        os.path.join("CLI", "darwin", arch, "miniooni"),
        "-ldflags=-s -w",
    ]
    if args.x:
        cmdline.append("-x")
    if args.verbose:
        cmdline.append("-v")
    if not args.no_embed_psiphon:
        cmdline.append("-tags=ooni_psiphon_config")
    cmdline.append("./internal/cmd/miniooni")
    execute(cmdline)
    unsetenv("GOARCH")
    unsetenv("GOOS")


def build_miniooni_linux(args, arch):
    """build_miniooni_windows builds miniooni for linux."""
    setenv("GOOS", "linux")
    setenv("GOARCH", arch)
    if arch == "arm":
        setenv("GOARM", "7")
    cmdline = [
        "go",
        "build",
        "-o",
        os.path.join("CLI", "linux", arch, "miniooni"),
        "-ldflags=-s -w -extldflags -static",
    ]
    if args.x:
        cmdline.append("-x")
    if args.verbose:
        cmdline.append("-v")
    tags = "-tags=netgo"
    if not args.no_embed_psiphon:
        tags += ",ooni_psiphon_config"
    cmdline.append(tags)
    cmdline.append("./internal/cmd/miniooni")
    execute(cmdline)
    unsetenv("GOARCH")
    unsetenv("GOOS")
    if arch == "arm":
        unsetenv("GOARM")


def build_miniooni_windows(args, arch):
    """build_miniooni_windows builds miniooni for windows."""
    setenv("GOOS", "windows")
    setenv("GOARCH", arch)
    cmdline = [
        "go",
        "build",
        "-o",
        os.path.join("CLI", "windows", arch, "miniooni.exe"),
        "-ldflags=-s -w",
    ]
    if args.x:
        cmdline.append("-x")
    if args.verbose:
        cmdline.append("-v")
    if not args.no_embed_psiphon:
        cmdline.append("-tags=ooni_psiphon_config")
    cmdline.append("./internal/cmd/miniooni")
    execute(cmdline)
    unsetenv("GOARCH")
    unsetenv("GOOS")


#
# Shell
#
# This section implements the "shell" subcommand.
#


def doshell() -> None:
    """doshell executes a shell with the correct environment
    variables to use our custom version of Go."""
    setupenv()
    execute([os.path.expandvars("${SHELL}")])


#
# Main
#
# This section contains the main function.
#

CLI_DESCRIPTION = """\
The `android` subcommand allows you to build OONI Probe as an Android
library. The output is `./MOBILE/android.bundle.jar` that you should
then upload to the Maven Central repository. To use the `android`
command you need to run the `init` command first.

The `help` command is syntactic sugar for `./build --help`.

The `init` subcommand initializes the state directory. This directory will
contain (1) a binary distribution of Go used for bootstrapping, (2) our
fork of Go used for compiling code, (3) a private GOPATH. Every time
you run the `init` command we wipe the state directory and start afresh.

The `miniooni` subcommand builds miniooni for every supported
architecture putting the results below `./CLI`.

The `shell` subcommand executes your $SHELL with a sligthly different $PS1
and environment variables such that you use our fork of Go and the
private GOPATH. Both are inside the state directory as described above.

The state directory is: {}

You can get more information on the flag supported by a subcommand running
`./build subcommand --help` (e.g., `./build android --help`).
"""


def newcliparser() -> None:
    """ newcliparser returns a new CLI parser. """
    root = argparse.ArgumentParser(
        epilog=CLI_DESCRIPTION.format(STATEDIR),
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    root.add_argument("-v", "--verbose", action="store_true", help="verbose mode")
    root.add_argument(
        "-x", action="store_true", help="tells Go to print invoked commands"
    )
    root_cmds = root.add_subparsers(dest="command")

    android = root_cmds.add_parser("android")
    android.add_argument(
        "--bundle",
        action="store_true",
        help="create bundle.jar for maven central (requires --sign)",
    )
    android.add_argument(
        "--sign",
        action="store",
        help="sign generated data with the specified PGP identity",
        metavar="EMAIL",
    )

    root_cmds.add_parser("help")

    init = root_cmds.add_parser("init")
    init.add_argument(
        "-f",
        "--force",
        action="store_true",
        help="force reinitialization",
    )

    miniooni = root_cmds.add_parser("miniooni")
    miniooni.add_argument(
        "--no-embed-psiphon",
        action="store_true",
        help="do not embed private psiphon config file",
    )
    miniooni.add_argument(
        "--no-ooni-go",
        action="store_true",
        help="do not use github.com/ooni/go",
    )
    miniooni_cmds = miniooni.add_subparsers(dest="miniooni_goos")
    miniooni_cmds.add_parser("darwin")
    miniooni_cmds.add_parser("linux")
    miniooni_cmds.add_parser("macos")
    miniooni_cmds.add_parser("windows")

    root_cmds.add_parser("shell")

    return root


def main() -> None:
    """ Main function. """
    parser = newcliparser()
    args = parser.parse_args()
    if args.command == "android":
        doandroid(args)
    elif args.command == "help":
        parser.print_help()
    elif args.command == "init":
        doinit()
    elif args.command == "miniooni":
        dominiooni(args)
    elif args.command == "shell":
        doshell()
    else:
        parser.print_help()
        sys.exit(1)


if __name__ == "__main__":
    main()